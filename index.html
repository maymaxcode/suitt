<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SuitCds Pro</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- JSZip para suporte a arquivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        /* Ajustes finos para scrollbar escura */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #18181b; }
        ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #52525b; }
        .spin-slow { animation: spin 3s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="min-h-screen bg-zinc-950 text-zinc-100 font-sans selection:bg-indigo-500/30 pb-32">

    <!-- AUDIO ENGINE (Invis√≠vel) -->
    <audio id="audio-preview"></audio>

    <!-- HEADER -->
    <header class="py-8 px-4 border-b border-zinc-900 bg-black/20 backdrop-blur-sm sticky top-0 z-40">
        <div class="max-w-2xl mx-auto flex items-center justify-between">
            <div>
                <h1 class="text-2xl font-bold tracking-tight text-white flex items-center gap-2">
                    <i data-lucide="layers" class="text-indigo-500"></i>
                    SuitCds
                </h1>
                <p class="text-xs text-zinc-500 font-medium tracking-widest mt-1">SUITE DE AUTOMA√á√ÉO DE √ÅUDIO</p>
            </div>
            <div class="flex gap-2 text-xs font-mono text-zinc-600">
                <span>V3.0</span>
                <span class="text-indigo-500">HTML</span>
            </div>
        </div>
    </header>

    <main class="max-w-2xl mx-auto p-4 space-y-8">
        
        <!-- SETOR 1: IDENTIDADE (VINHETA) -->
        <section>
            <h2 class="text-xs font-bold text-zinc-500 uppercase mb-3 flex items-center gap-2">
                <i data-lucide="radio" class="w-3 h-3"></i> Identidade Sonora
            </h2>
            
            <div class="relative group overflow-hidden rounded-2xl bg-zinc-900 border border-zinc-800 hover:border-indigo-500/50 transition-all">
                <input type="file" id="vinheta-input" accept="audio/*,video/*" class="absolute inset-0 z-20 opacity-0 cursor-pointer" />
                <div class="p-6 flex items-center justify-between">
                    <div class="flex items-center gap-4">
                        <div id="vinheta-icon-container" class="w-12 h-12 rounded-full flex items-center justify-center bg-zinc-800 text-zinc-600">
                            <i data-lucide="volume-2" class="w-5 h-5"></i>
                        </div>
                        <div>
                            <div id="vinheta-name" class="font-medium text-sm text-zinc-200">
                                Carregar Vinheta Principal
                            </div>
                            <div id="vinheta-info" class="text-xs text-zinc-500 mt-0.5">
                                Toque para selecionar MP3 ou MP4
                            </div>
                        </div>
                    </div>
                    <div id="vinheta-badge" class="hidden text-xs font-bold text-indigo-400 bg-indigo-500/10 px-3 py-1 rounded-full">PRONTO</div>
                </div>
            </div>
        </section>

        <!-- SETOR 2: CONFIGURA√á√ïES -->
        <section>
            <h2 class="text-xs font-bold text-zinc-500 uppercase mb-3 flex items-center gap-2">
                <i data-lucide="sliders" class="w-3 h-3"></i> L√≥gica de Mixagem
            </h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                <!-- ONDE INSERIR -->
                <div class="bg-zinc-900 p-3 rounded-xl border border-zinc-800">
                    <label class="text-[10px] text-zinc-500 uppercase font-bold mb-2 block">Detec√ß√£o</label>
                    <select id="detect-mode" class="w-full bg-black text-xs p-2 rounded border border-zinc-700 outline-none focus:border-indigo-500 text-white">
                        <option value="start">In√≠cio (0:00)</option>
                        <option value="smart30" selected>Smart (Primeiros 30s)</option>
                        <option value="smart60">Smart (Primeiro 1min)</option>
                        <option value="calmest">Scanner (M√∫sica Toda)</option>
                    </select>
                </div>

                <!-- COMO MIXAR -->
                <div class="bg-zinc-900 p-3 rounded-xl border border-zinc-800">
                    <label class="text-[10px] text-zinc-500 uppercase font-bold mb-2 block">Estilo Mix</label>
                    <select id="mix-mode" class="w-full bg-black text-xs p-2 rounded border border-zinc-700 outline-none focus:border-indigo-500 text-white">
                        <option value="ducking" selected>R√°dio (Suave)</option>
                        <option value="cut">Seco (Corte Total)</option>
                        <option value="overlay">Rave (Por Cima)</option>
                    </select>
                </div>

                <!-- EFEITOS -->
                <div class="bg-zinc-900 p-3 rounded-xl border border-zinc-800">
                    <label class="text-[10px] text-zinc-500 uppercase font-bold mb-2 block flex items-center gap-1">
                        Efeitos SFX <i data-lucide="zap" class="w-3 h-3 text-yellow-500 ml-1"></i>
                    </label>
                    <select id="sfx-mode" class="w-full bg-black text-xs p-2 rounded border border-zinc-700 outline-none focus:border-indigo-500 text-white">
                        <option value="none" selected>Nenhum</option>
                        <option value="airhorn">üì£ Airhorn (Reggae)</option>
                        <option value="impact">üí• Impacto (Boom)</option>
                    </select>
                </div>
            </div>
        </section>

        <!-- SETOR 3: PLAYLIST -->
        <section>
            <h2 class="text-xs font-bold text-zinc-500 uppercase mb-3 flex items-center gap-2">
                <i data-lucide="disc" class="w-3 h-3"></i> Playlist
            </h2>

            <div class="flex gap-2 mb-4">
                 <div class="relative flex-1">
                    <input type="file" id="music-input" multiple accept="audio/*,video/*" class="absolute inset-0 opacity-0 cursor-pointer z-10"/>
                    <button class="w-full bg-zinc-800 hover:bg-zinc-700 text-zinc-300 py-3 rounded-xl text-xs font-bold transition-colors border border-zinc-700 flex justify-center items-center gap-2">
                        + ARQUIVOS SOLTOS
                    </button>
                 </div>
                 <div class="relative flex-1">
                    <input type="file" id="zip-input" accept=".zip" class="absolute inset-0 opacity-0 cursor-pointer z-10"/>
                    <button class="w-full bg-zinc-800 hover:bg-zinc-700 text-zinc-300 py-3 rounded-xl text-xs font-bold transition-colors border border-zinc-700 flex items-center justify-center gap-2">
                        <i data-lucide="archive" class="w-3 h-3"></i> IMPORTAR ZIP
                    </button>
                 </div>
            </div>

            <div class="bg-zinc-900 border border-zinc-800 rounded-xl overflow-hidden min-h-[100px]">
                <div id="track-list" class="divide-y divide-zinc-800 max-h-[400px] overflow-y-auto">
                    <!-- Lista vazia inicial -->
                    <div class="p-8 text-center text-zinc-600 text-xs flex flex-col items-center">
                        <p>Arraste arquivos ou selecione acima.</p>
                        <p class="mt-1">Aceita MP3, WAV, MP4 e ZIP.</p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <!-- FOOTER ACTIONS -->
    <footer class="fixed bottom-0 left-0 right-0 bg-zinc-950/80 backdrop-blur-md border-t border-zinc-900 p-4 z-50">
         <div class="max-w-2xl mx-auto flex gap-3">
            <button id="process-btn" disabled class="flex-1 py-4 rounded-xl font-bold text-sm flex items-center justify-center gap-2 transition-all bg-zinc-800 text-zinc-500 cursor-not-allowed">
                <i data-lucide="zap" class="w-4 h-4 fill-current"></i>
                <span id="process-btn-text">INICIAR MIXAGEM</span>
            </button>
            
            <button id="download-zip-btn" class="hidden w-1/3 bg-indigo-600 hover:bg-indigo-500 text-white rounded-xl font-bold text-sm flex items-center justify-center gap-2 transition-all">
                <i data-lucide="download" class="w-4 h-4"></i>
                ZIP
            </button>
         </div>
    </footer>

    <!-- SCRIPT PRINCIPAL -->
    <script>
        // --- ESTADO GLOBAL ---
        let audioContext = null;
        let vinhetaBuffer = null;
        let vinhetaDuration = 0;
        let tracks = []; // { id, file, status, blob, message, isVideo }
        let processing = false;
        let playingId = null;

        // Elementos DOM
        const vinhetaInput = document.getElementById('vinheta-input');
        const musicInput = document.getElementById('music-input');
        const zipInput = document.getElementById('zip-input');
        const processBtn = document.getElementById('process-btn');
        const processBtnText = document.getElementById('process-btn-text');
        const downloadZipBtn = document.getElementById('download-zip-btn');
        const trackListEl = document.getElementById('track-list');
        const audioPreview = document.getElementById('audio-preview');

        // Inicializar √≠cones
        lucide.createIcons();

        // --- AUDIO ENGINE ---

        // Inicializa Contexto de √Åudio (User Gesture)
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        window.addEventListener('click', initAudio, { once: true });
        window.addEventListener('touchstart', initAudio, { once: true });

        // WAV Encoder
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample, offset = 0, pos = 0;

            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
            function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }

            setUint32(0x46464952); // "RIFF"
            setUint32(length - 8); setUint32(0x45564157); // "WAVE"
            setUint32(0x20746d66); // "fmt "
            setUint32(16); setUint16(1); setUint16(numOfChan);
            setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); // "data"
            setUint32(length - pos - 4);

            for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

            while(pos < len) {
                for(i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][pos]));
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0;
                    view.setInt16(44 + offset, sample, true); offset += 2;
                }
                pos++;
            }
            return new Blob([buffer], { type: "audio/wav" });
        }

        // SFX Generator
        async function generateSFX(ctx, type) {
            const sampleRate = ctx.sampleRate;
            if (type === 'none') return null;

            if (type === 'airhorn') {
                const duration = 1.5;
                const buffer = ctx.createBuffer(2, sampleRate * duration, sampleRate);
                for (let c = 0; c < 2; c++) {
                    const data = buffer.getChannelData(c);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sampleRate;
                        const freq = 400; 
                        const signal = (Math.sin(t * freq * 6.28) + Math.sin(t * (freq + 5) * 6.28)) * 0.5;
                        const envelope = Math.max(0, 1 - (t / duration));
                        data[i] = (signal > 0 ? 0.5 : -0.5) * envelope * 0.4;
                    }
                }
                return buffer;
            }
            if (type === 'impact') {
                const duration = 2.0;
                const buffer = ctx.createBuffer(2, sampleRate * duration, sampleRate);
                for (let c = 0; c < 2; c++) {
                    const data = buffer.getChannelData(c);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sampleRate;
                        const noise = (Math.random() * 2 - 1);
                        const sine = Math.sin(t * 50 * 6.28); 
                        const envelope = Math.exp(-t * 3);
                        data[i] = (noise * 0.3 + sine * 0.7) * envelope;
                    }
                }
                return buffer;
            }
            return null;
        }

        // Find best spot
        function findBestSpot(musicBuffer, vDuration, mode) {
            if (mode === 'start') return 0;
            const sampleRate = musicBuffer.sampleRate;
            let maxSearchTime = 30;
            if (mode === 'smart60') maxSearchTime = 60;
            if (mode === 'calmest') maxSearchTime = musicBuffer.duration;

            const rawData = musicBuffer.getChannelData(0);
            const searchSamples = Math.min(rawData.length, sampleRate * maxSearchTime);
            const vinhetaSamples = Math.ceil(vDuration * sampleRate);
            const step = mode === 'calmest' ? Math.floor(sampleRate * 1.0) : Math.floor(sampleRate * 0.5);

            let minEnergy = Infinity;
            let bestStartSample = 0;

            for (let i = 0; i < searchSamples - vinhetaSamples; i += step) {
                let sumSquares = 0;
                const analyzeLimit = 500; 
                for (let j = 0; j < analyzeLimit; j++) {
                    const idx = Math.floor(i + (j * (vinhetaSamples / analyzeLimit)));
                    if (idx < rawData.length) sumSquares += rawData[idx] * rawData[idx];
                }
                const rms = Math.sqrt(sumSquares / analyzeLimit);
                if (rms < minEnergy) { minEnergy = rms; bestStartSample = i; }
            }
            return bestStartSample / sampleRate;
        }

        // Process Single Track
        async function processTrack(track) {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const ctx = audioContext;

            try {
                // Configs
                const detectMode = document.getElementById('detect-mode').value;
                const mixMode = document.getElementById('mix-mode').value;
                const sfxMode = document.getElementById('sfx-mode').value;

                const ab = await track.file.arrayBuffer();
                const musicBuffer = await ctx.decodeAudioData(ab);
                
                const sfxBuffer = await generateSFX(ctx, sfxMode);
                const sfxDur = sfxBuffer ? sfxBuffer.duration : 0;
                
                const totalDur = vinhetaDuration + (sfxDur > 0 ? sfxDur * 0.5 : 0);
                const startTime = findBestSpot(musicBuffer, totalDur, detectMode);

                const offlineCtx = new OfflineAudioContext(2, musicBuffer.length, musicBuffer.sampleRate);

                // Music Layer
                const mSrc = offlineCtx.createBufferSource(); mSrc.buffer = musicBuffer;
                const mGain = offlineCtx.createGain();
                const fadeT = 0.3; 
                const endT = startTime + totalDur;

                mGain.gain.setValueAtTime(1, 0);
                if (mixMode === 'ducking') {
                    mGain.gain.setValueAtTime(1, startTime);
                    mGain.gain.linearRampToValueAtTime(0.25, startTime + fadeT);
                    mGain.gain.setValueAtTime(0.25, endT - fadeT);
                    mGain.gain.linearRampToValueAtTime(1, endT);
                } else if (mixMode === 'cut') {
                    mGain.gain.setValueAtTime(1, startTime);
                    mGain.gain.linearRampToValueAtTime(0, startTime + 0.05);
                    mGain.gain.setValueAtTime(0, endT - 0.05);
                    mGain.gain.linearRampToValueAtTime(1, endT);
                }
                mSrc.connect(mGain); mGain.connect(offlineCtx.destination); mSrc.start(0);

                // SFX Layer
                if (sfxBuffer) {
                    const sSrc = offlineCtx.createBufferSource(); sSrc.buffer = sfxBuffer;
                    const sGain = offlineCtx.createGain(); sGain.gain.value = 0.8;
                    sSrc.connect(sGain); sGain.connect(offlineCtx.destination); sSrc.start(startTime);
                }

                // Vinheta Layer
                const vSrc = offlineCtx.createBufferSource(); vSrc.buffer = vinhetaBuffer;
                const vGain = offlineCtx.createGain(); 
                vGain.gain.value = mixMode === 'overlay' ? 1.3 : 1.1;
                vSrc.connect(vGain); vGain.connect(offlineCtx.destination);
                vSrc.start(startTime + (sfxBuffer ? 0.5 : 0));

                const rendered = await offlineCtx.startRendering();
                const blob = bufferToWave(rendered, rendered.length);

                track.status = 'done';
                track.blob = blob;
                track.message = `Mixado em ${startTime.toFixed(0)}s`;

            } catch (e) {
                console.error(e);
                track.status = 'error';
                track.message = 'Erro (DRM/Inv√°lido)';
            }
            renderTracks();
            updateButtons();
        }

        // --- UI HANDLERS ---

        // Render Tracks List
        function renderTracks() {
            if (tracks.length === 0) {
                trackListEl.innerHTML = `
                    <div class="p-8 text-center text-zinc-600 text-xs flex flex-col items-center">
                        <p>Arraste arquivos ou selecione acima.</p>
                        <p class="mt-1">Aceita MP3, WAV, MP4 e ZIP.</p>
                    </div>`;
                return;
            }

            trackListEl.innerHTML = '';
            tracks.forEach(track => {
                const isPlaying = playingId === track.id;
                
                let iconClass = track.status === 'done' ? 'bg-green-500/10 text-green-500' : 'bg-zinc-800 text-zinc-500';
                let icon = track.status === 'processing' ? '<i data-lucide="loader-2" class="w-3.5 h-3.5 spin-slow"></i>' : '<i data-lucide="music" class="w-3.5 h-3.5"></i>';

                const row = document.createElement('div');
                row.className = 'p-3 flex items-center justify-between hover:bg-zinc-800/50 transition-colors';
                row.innerHTML = `
                    <div class="flex items-center gap-3 min-w-0">
                        <div class="w-8 h-8 rounded flex items-center justify-center ${iconClass}">
                            ${icon}
                        </div>
                        <div class="min-w-0">
                            <div class="text-xs font-medium text-zinc-300 truncate w-32 md:w-64">${track.file.name}</div>
                            <div class="text-[10px] text-zinc-500 uppercase">${track.message}</div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        ${track.status === 'done' ? `
                            <button onclick="togglePreview('${track.id}')" class="p-2 rounded hover:bg-zinc-700 ${isPlaying ? 'text-indigo-400' : 'text-zinc-400'}">
                                <i data-lucide="${isPlaying ? 'pause' : 'play'}" class="w-3.5 h-3.5"></i>
                            </button>
                        ` : ''}
                        <button onclick="removeTrack('${track.id}')" class="p-2 text-zinc-600 hover:text-red-400">
                            <i data-lucide="x" class="w-3.5 h-3.5"></i>
                        </button>
                    </div>
                `;
                trackListEl.appendChild(row);
            });
            lucide.createIcons();
        }

        // Button State
        function updateButtons() {
            const hasVinheta = !!vinhetaBuffer;
            const hasTracks = tracks.length > 0;
            const hasDone = tracks.some(t => t.status === 'done');

            if (processing) {
                processBtn.disabled = true;
                processBtn.className = "flex-1 py-4 rounded-xl font-bold text-sm flex items-center justify-center gap-2 transition-all bg-zinc-800 text-zinc-500 cursor-wait";
                processBtnText.innerText = "PROCESSANDO...";
            } else if (hasVinheta && hasTracks) {
                processBtn.disabled = false;
                processBtn.className = "flex-1 py-4 rounded-xl font-bold text-sm flex items-center justify-center gap-2 transition-all bg-white text-black hover:bg-zinc-200 cursor-pointer shadow-lg";
                processBtnText.innerText = "INICIAR MIXAGEM";
            } else {
                processBtn.disabled = true;
                processBtn.className = "flex-1 py-4 rounded-xl font-bold text-sm flex items-center justify-center gap-2 transition-all bg-zinc-800 text-zinc-500 cursor-not-allowed";
                processBtnText.innerText = "INICIAR MIXAGEM";
            }

            if (hasDone && !processing) {
                downloadZipBtn.classList.remove('hidden');
            } else {
                downloadZipBtn.classList.add('hidden');
            }
            lucide.createIcons();
        }

        // --- EVENT LISTENERS ---

        // Vinheta Upload
        vinhetaInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            initAudio();
            try {
                const ab = await file.arrayBuffer();
                vinhetaBuffer = await audioContext.decodeAudioData(ab);
                vinhetaDuration = vinhetaBuffer.duration;
                
                document.getElementById('vinheta-name').innerText = file.name;
                document.getElementById('vinheta-info').innerText = `${vinhetaDuration.toFixed(1)}s ‚Ä¢ Carregado`;
                
                const iconContainer = document.getElementById('vinheta-icon-container');
                iconContainer.className = "w-12 h-12 rounded-full flex items-center justify-center bg-indigo-500 text-white";
                if(file.type.includes('video')) {
                     iconContainer.innerHTML = '<i data-lucide="file-video" class="w-5 h-5"></i>';
                } else {
                     iconContainer.innerHTML = '<i data-lucide="volume-2" class="w-5 h-5"></i>';
                }
                
                document.getElementById('vinheta-badge').classList.remove('hidden');
                updateButtons();
                lucide.createIcons();
            } catch (err) {
                alert("Erro ao ler vinheta.");
                console.error(err);
            }
        });

        // Music Upload
        musicInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            files.forEach(f => {
                tracks.push({
                    id: Math.random().toString(36).substr(2, 9),
                    file: f,
                    status: 'pending',
                    message: 'Aguardando',
                    blob: null
                });
            });
            renderTracks();
            updateButtons();
        });

        // ZIP Upload
        zipInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const zip = new JSZip();
                const content = await zip.loadAsync(file);
                
                for (const filename of Object.keys(content.files)) {
                    const entry = content.files[filename];
                    if (!entry.dir && !filename.startsWith('__') && filename.match(/\.(mp3|wav|m4a|mp4)$/i)) {
                        const blob = await entry.async("blob");
                        const newFile = new File([blob], filename.split('/').pop(), { type: 'audio/mpeg' });
                        tracks.push({
                            id: Math.random().toString(36).substr(2, 9),
                            file: newFile,
                            status: 'pending',
                            message: 'Do ZIP',
                            blob: null
                        });
                    }
                }
                renderTracks();
                updateButtons();
            } catch (err) {
                alert("Erro ao ler ZIP.");
            }
        });

        // Process Action
        processBtn.addEventListener('click', async () => {
            if (processing) return;
            processing = true;
            updateButtons();
            renderTracks(); // Show spinners

            for (let i = 0; i < tracks.length; i++) {
                if (tracks[i].status !== 'done') {
                    tracks[i].status = 'processing';
                    renderTracks();
                    // Pequeno delay para a UI atualizar
                    await new Promise(r => setTimeout(r, 50));
                    await processTrack(tracks[i]);
                }
            }
            processing = false;
            updateButtons();
            renderTracks();
        });

        // Remove Track
        window.removeTrack = (id) => {
            if (playingId === id) {
                audioPreview.pause();
                playingId = null;
            }
            tracks = tracks.filter(t => t.id !== id);
            renderTracks();
            updateButtons();
        };

        // Preview
        window.togglePreview = (id) => {
            const track = tracks.find(t => t.id === id);
            if (!track || !track.blob) return;

            if (playingId === id) {
                audioPreview.pause();
                playingId = null;
            } else {
                audioPreview.src = URL.createObjectURL(track.blob);
                audioPreview.play();
                playingId = id;
            }
            renderTracks(); // Updates icons
        };

        audioPreview.onended = () => {
            playingId = null;
            renderTracks();
        };

        // Download ZIP
        downloadZipBtn.addEventListener('click', async () => {
            const zip = new JSZip();
            let count = 0;
            tracks.forEach(t => {
                if (t.status === 'done' && t.blob) {
                    zip.file(`${t.file.name.replace(/\.[^/.]+$/, "")}_SuitCds.wav`, t.blob);
                    count++;
                }
            });
            
            if (count === 0) return;

            const content = await zip.generateAsync({type:"blob"});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = "SuitCds_Pack.zip";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

    </script>
</body>
</html>

